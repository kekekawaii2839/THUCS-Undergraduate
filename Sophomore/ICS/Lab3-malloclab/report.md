# LAB 3 - Malloc Lab

## 算法设计思路

本次实验中, 我采用了分离的空闲链表, 具体实现上采取了分离适配.

### 分配算法设计

首先需要对 `size` 做 16 字节对齐, 并且考虑到空闲块包含 header, footer, 前驱和后继的地址 , 最小也需要 $4\times8=32$ 字节.

之后需要做首次适配, 从链表头开始遍历, 找到第一个满足条件的空闲块, 然后将该块移出当前大小类的链表, 调用 `place()` 进行对块的分割处理, 如果有分割出来的空闲块就再放回相应类的链表中.

这里我做了一些算法策略上的调整: 
- 链表的组织方式上, 我在每次插入的时候保证链表是按从小到大排列的, 因此首次适配找到的空闲块一定是符合条件且最小的块, 尽可能地减少了分割的情况, 从而较少外部碎片化; 

- 同时 `place()` 的策略我也调整了一些, 如果分割后已分配块的大小大于某个 magic number , 那么分割时我就将空闲块放在前, 已分配块放在后, 这样会一定程度上减少外部碎片化. 经过多次试验, magic number 取 96 的效果最好.

### 回收算法设计

回收算法我并没有做过多调整, 只是需要先将待释放块与前后可能的空闲块合并, 然后将合并后的空闲块放到相应大小类的链表中.

## 性能评估细节

以下是我在课程服务器上运行最终版本的得分结果:

```text
ics-2022011545@conv0:~/lab3$ ./mdriver -v
Team Name:MyGO
Member 1 :Li Haolun:2022011545
Using default tracefiles in ./traces/
Measuring performance with gettimeofday().

Results for mm malloc:
trace            name     valid  util     ops      secs   Kops
 1     amptjp-bal.rep       yes   99%    5694  0.000268  21215
 2       cccp-bal.rep       yes   99%    5848  0.000245  23889
 3    cp-decl-bal.rep       yes   99%    6648  0.000268  24787
 4       expr-bal.rep       yes   99%    5380  0.000196  27463
 5 coalescing-bal.rep       yes   98%   14400  0.000282  51118
 6     random-bal.rep       yes   96%    4800  0.000447  10736
 7    random2-bal.rep       yes   95%    4800  0.000433  11080
 8     binary-bal.rep       yes   91%   12000  0.003727   3219
 9    binary2-bal.rep       yes   81%   24000  0.000726  33081
10    realloc-bal.rep       yes   99%   14401  0.000272  52867
11   realloc2-bal.rep       yes   99%   14401  0.000122 117751
Total                             96%  112372  0.006987  16083

Score = (58 (util) + 40 (thru)) * 11/11 (testcase) = 98/100
```

可以看到整体上耗时都能满足要求, 并且空间利用率保证一定水平.

对于 binary2-bal.rep 这个测例, 空间利用率较低其实是数据上的巧合. 经过检查后我发现, 堆的分配基本上是这样的: 
```text
32 32 32 ... 32 128 128 ... 128
```
每次新开辟的块(大小为 4096 字节)正好被上述方式分割, 而本测例的数据分配总字节数又正好不是 4096 的整数倍, 所以导致最后一个块的中间会有大约 3000 字节的空闲块, 从而导致空间利用率的下降.

## 性能分析

时间复杂度:
- 初始化为 $O(1)$ .
- 分配为最好为 $O(1)$, 最坏为 $O(\sum x_i)$ , 其中 $x_i$ 为第 $i$ 个链表中已有的空闲块数.
- 回收为最好为 $O(1)$, 最坏为 $O(x_i)$ , 因为其中需要把释放后产生的空闲块放到对应大小类的链表里, 复杂度就来自于这步操作中遍历链表的时间.
- 重分配最好为 $O(1)$, 最坏为 $O(\sum x_i)$, 因为重分配比分配多出的操作均可以在常数时间内完成(包括合并, 分割, 复制, 空闲块移出链表).